---
title: "스위프트 알고리즘 클럽 번역, 퀵 소트"
toc: true
toc_sticky: true
categories:
    - study
tags:
	- study
    - 알고리즘
last_modified_at: 2021-09-23
---

# 퀵 소트

> 목표: 오름차순 혹은 내림차순으로 배열을 정렬하기

퀵 소트는 역사에 남은 가장 유명한 알고리즘 중 하나이다. 아직 재귀에 대한 개념이 모호하던 1959년 Tony Hoare에 의해 고안되었다.

이해하기 쉽도록 Swift 코드로 구현해 보면 다음과 같다.

```swift
func quickSort<T: Comparable>(_ a: [T]) -> [T] {
	guard a.count > 1 else { return a }

	let pivot = a[a.count / 2]
	let less = a.filter { $0 < pivot }
	let equal = a.filter { $0 == pivot }
	let greater = a.filter { $0 > pivot }

	return quickSort(less) + equal + quickSort(greater)
}
```

배열이 주어지고, `quickSort()`는 이 배열을 `pivot` 변수에 기반해 세 부분으로 나눈다. 여기에서 pivot은 배열의 가운데 요소로 정해졌다(나중에 피벗을 정하는 다른 방법을 선택할 수 있다).

피벗보다 작은 요소들은 `less` 배열로 들어간다. 피벗과 같은 요소들은 `equal` 배열로 들어간다. 예상했듯, 피벗보다 큰 요소들은 모두 `greater`에 들어간다. 요소들을 `<`, `==`, `>`로 비교하기 위해서 제네릭 타입의 `T`가 `Comparable`인 것이다.

배열이 세 등분 되었으면 `quickSort()`는 `less`와 `greater` 배열을 재귀적으로 정렬하고, 정렬된 하위 배열들(less, greater)과 `equal` 배열이 합쳐져 결과로 도출된다.

## 예시

## 파티셔닝

배열을 피벗을 중심으로 나누는 것을 `파티셔닝`이라 하고, 여기엔 몇 가지 다른 파티셔닝 방법들이 있다.

```swift
[ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ]
```

배열이 다음과 같을 때, 중간에 위치한 요소 `8`을 피벗으로 정한 뒤 파티셔닝하면 다음과 같다.

```
[ 0, 3, 2, 1, 5, -1, 8, 8, 10, 9, 14, 27, 26 ]
  -----------------        -----------------
  all elements < 8         all elements > 8
```

여기서 중요한 점은, 파티셔닝을 한 후 피벗이 되는 요소는 마지막으로 정렬될 위치에 미리 존재해야 한다는 것이다. 나머지 숫자들은 아직 정렬되지 않은 채 단순히 피벗을 기준으로 나뉘어졌을 뿐이다. 퀵 소트는 배열을 계속해서 파티셔닝해 모든 값들이 마지막 위치에(정렬된 위치에) 위치하도록 한다.

파티셔닝은 요소들이 매번 같은 순서로 분리되는 것을 보장하지 못하며, `8`로 파티셔닝을 한 후 다음과 같이 분리될수도 있다.

```
[ 3, 0, 5, 2, -1, 1, 8, 8, 14, 26, 10, 27, 9 ]
```

딱 한가지 보장되는 것은 피벗을 기준으로 왼쪽은 작은 요소들, 오른쪽은 큰 요소들이 모여 있다는 점이다. 파티셔닝을 하다보면 배열이 본래의 순서가 바뀔 수 있기 때문에 퀵소트는 "안정된" 정렬기법(합병정렬과 다르게)이 아니다. 대부분의 경우 이는 큰 상관이 없다.

## Lomuto의 파티셔닝

## Hoare의 파티셔닝

## 좋은 피벗 뽑기

Lomuto의 파티셔닝은 항상 배열의 마지막 요소를 피벗으로 지정한다. Hoare의 파티셔닝은 항상 첫번째 요소를 사용한다. 하지만 이 피벗들이 최선이라는 보장이 없다. 다음은 피벗으로 별로 좋지 않은 값을 뽑았을 때 일어나는 일이다.

```
[ 7, 6, 5, 4, 3, 2, 1 ]
```

배열이 다음과 같을 때, Lomuto의 파티셔닝을 사용한다고 가정하자. 피벗은 마지막 요소인 `1`이 된다. 피벗을 정한 후 우리는 다음과 같은 배열을 얻게 된다.

```
less than pivot: [ ]
equal to pivot: [ 1 ]
greater than pivot: [ 7, 6, 5, 4, 3, 2 ]
```

재귀적으로 `큰` 값들을 파티셔닝해보면 다음과 같은 하위 배열이 만들어진다.

```
less than pivot: [ ]
equal to pivot: [ 2 ]
greater than pivot: [ 7, 6, 5, 4, 3 ]
```

그리고 계속 이와 같이 쭉 반복된다.

이는 별로 좋지 않은데, 퀵 소트를 퀵 소트보다 한참 느린 삽입 정렬처럼 사용하고 있기 때문이다. 퀵 소트를 효과적으로 사용하기 위해선, 배열을 대충 반으로 나눌 수 있어야 한다.

위의 예시에서 최적의 피벗은 `4`이고, 이를 통해 다음과 같은 배열을 얻을 수 있다.

```
less than pivot: [ 3, 2, 1 ]
equal to pivot: [ 4 ]
greater than pivot: [ 7, 6, 5 ]
```

맨 처믕 혹은 맨 뒤 요소를 뽑는 대신 중간에 있는 요소를 뽑는 게 좋을 것 같다고 생각할 수 있지만, 다음과 같은 상황을 상상해보자.

```
[ 7, 6, 5, 1, 4, 3, 2 ]
```

중간에 있는 요소가 `1`이므로, 앞선 예시와 같이 비효율적인 방식으로 진행될 것이다.

이상적인 피벗은 파티셔닝할 배열의 `중간값`, 즉 정렬된 배열의 중간에 위치할 요소이다.