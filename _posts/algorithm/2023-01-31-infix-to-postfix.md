---
title: "ì¤‘ìœ„í‘œí˜„ì‹ì„ í›„ìœ„í‘œí˜„ì‹ìœ¼ë¡œ ë°”ê¿”ì„œ ì—°ì‚°í•˜ê¸°(feat. ë¬¸ìì—´ ì‚¬ì¹™ì—°ì‚°, ì´ì§„íŠ¸ë¦¬)"
toc: true
toc_sticky: true
categories:
    - ğŸ“‚ all
    - swift
tags:
    - swift
    - ìŠ¤ìœ„í”„íŠ¸
    - ì•Œê³ ë¦¬ì¦˜
last_modified_at: 2023-01-31
---

## ë¬¸ìì—´ë¡œ ë“¤ì–´ì˜¨ ì‚¬ì¹™ì—°ì‚°ì„ ì–´ë–»ê²Œ í’€ê¹Œ?

ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë¥¼ í’€ë‹¤ë³´ë©´ `"1 + (2 - (3 * 7)) + (5 * 10)"` ì´ëŸ° ë¬¸ìì—´ í˜•ì‹ì˜ ì‚¬ì¹™ì—°ì‚°ì„ í’€ì–´ë‚´ëŠ” ë¬¸ì œë“¤ì´ ê°€ë” ë‚˜ì˜¨ë‹¤.

ìš°ë¦¬ëŠ” ì§ê´€ì ìœ¼ë¡œ ê°€ì¥ ì•ˆìª½ ê´„í˜¸ë¶€í„° ê³„ì‚°í•˜ê³ , ê´„í˜¸ê°€ ì—†ë‹¤ë©´ ê³±ì…ˆ/ë‚˜ëˆ—ì…ˆ, ë§ì…ˆ/ëº„ì…ˆ ìˆœìœ¼ë¡œ ë¨¼ì € ê³„ì‚°í•œë‹¤ëŠ” ê²ƒì„ ì•Œê³  ìˆë‹¤. í•˜ì§€ë§Œ ì»´í“¨í„°ëŠ” í•­ìƒ ê·¸ë ‡ì§€ ì•Šë‹¤..!

ê·¸ë˜ì„œ ë¬¸ìì—´ í˜•ì‹ì˜ ì‚¬ì¹™ì—°ì‚°ì„ í•˜ë‚˜í•˜ë‚˜ ìª¼ê°œ ìš°ì„ ìˆœìœ„ë¥¼ ë¶€ì—¬í•´ì£¼ê³ , ê·¸ ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ì°¨ë¡€ëŒ€ë¡œ ì—°ì‚°ì„ í•´ë‚˜ê°€ë„ë¡ ì•Œê³ ë¦¬ì¦˜ì„ ì§œì•¼ í•œë‹¤.

ì´ë¥¼ í’€ì–´ë‚´ê¸° ìœ„í•´ `ì¤‘ìœ„í‘œí˜„ì‹ì„ í›„ìœ„í‘œí˜„ì‹ìœ¼ë¡œ`, `í›„ìœ„í‘œí˜„ì‹ì„ ì´ì§„íŠ¸ë¦¬ë¡œ` ë§Œë“¤ì–´ `íŠ¸ë¦¬ë¥¼ íƒìƒ‰í•˜ë©´ì„œ ê°’ì„ ì—°ì‚°`í•  ê²ƒì´ë‹¤.

## í‘œí˜„ì‹(Expression)

[ìœ„í‚¤í”¼ë””ì•„](https://en.wikipedia.org/wiki/Expression_(computer_science))ì— ë”°ë¥´ë©´, í‘œí˜„ì‹ì€ ê°’ì„ ì•Œ ìˆ˜ ìˆëŠ” ì–´ë– í•œ í˜•íƒœì˜ êµ¬ë¬¸ì´ë‹¤. ìˆ˜í•™ì—ì„œ ìˆ˜ì‹ì„ ì»´í“¨í„°ê³µí•™ì—ì„  í‘œí˜„ì‹ì´ë¼ê³  ë¶€ë¥´ëŠ” ê²ƒ ê°™ë‹¤.

ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë§Œë“¤ ì‚¬ì¹™ì—°ì‚° ë¿ë§Œ ì•„ë‹ˆë¼, ë³€ìˆ˜ì— ê°’ì„ í• ë‹¹í•˜ëŠ” ê²ƒë„ í‘œí˜„ì‹ì´ ë  ìˆ˜ ìˆë‹¤ê³  í•œë‹¤.

ì§€ê¸ˆì€ ì‚¬ì¹™ì—°ì‚°ì„ ì»´í“¨í„°ê°€ ì´í•´í•  ìˆ˜ ìˆëŠ” í‘œí˜„ì‹ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” ê²ƒì´ ëª©ì ì´ê¸° ë•Œë¬¸ì— ë‹¤ë¥¸ê±´ ëê³  ì—°ì‚°ì„ í•  ìˆ˜ ìˆëŠ” í‘œí˜„ì‹ì— ëŒ€í•´ì„œ ì•Œì•„ë³´ì!

### ì¤‘ìœ„, í›„ìœ„, ì „ìœ„ í‘œí˜„ì‹(Infix, Postfix, Prefix Expression)

ì¤‘ìœ„, í›„ìœ„, ì „ìœ„ í‘œí˜„ì‹ì€ í‘œí˜„ì‹ì„ ì„œìˆ í•  ìˆ˜ ìˆëŠ” ê°ê¸° ë‹¤ë¥¸ ë°©ë²•ì´ë‹¤. ê²°ê³¼ê°’ì€ ë™ì¼í•˜ë‹¤. [(ì •ì˜ ì¶œì²˜)](https://www.cs.man.ac.uk/~pjj/cs212/fix.html)

ìš°ë¦¬ê°€ ì•Œê³  ìˆëŠ” ê¸°ë³¸ì ì¸ í˜•íƒœì˜ í‘œí˜„ì‹ì€ ì¤‘ìœ„í‘œí˜„ì‹ìœ¼ë¡œ, ì—°ì‚°ìê°€ í”¼ì—°ì‚°ì ì¤‘ê°„ì— ìœ„ì¹˜í•œë‹¤. ì‚¬ì¹™ì—°ì‚°ì„ ìœ„í•œ ì—°ì‚°ì ë¿ë§Œ ì•„ë‹ˆë¼ ì¤‘ìœ„í‘œí˜„ì‹ì—ì„  ê´„í˜¸ê°€ ê°’ì— ì˜í–¥ì„ ë¯¸ì¹œë‹¤.

í›„ìœ„í‘œí˜„ì‹ì€ ì—°ì‚°ìê°€ í”¼ì—°ì‚°ì ë’¤ì— ìœ„ì¹˜í•˜ëŠ” ê²ƒ, ì „ìœ„í‘œí˜„ì‹ì€ ì—°ì‚°ìê°€ í”¼ì—°ì‚°ì ì•ì— ìœ„ì¹˜í•˜ëŠ” ê²ƒì´ë‹¤.

## ì´ì§„íŠ¸ë¦¬(Binary Tree)

ë¶€ëª¨-ìì‹ìœ¼ë¡œ ì—°ê²°ëœ íŠ¸ë¦¬ êµ¬ì¡°ì—ì„œ, ë¶€ëª¨ê°€ ë‹¨ ë‘ê°œì˜ ìì‹ë§Œì„ ê°–ëŠ” íŠ¸ë¦¬ë¥¼ ì´ì§„ íŠ¸ë¦¬ë¼ê³  í•œë‹¤.

ìë£Œêµ¬ì¡°ì¤‘ `í™(Heap)`ì„ êµ¬í˜„í•  ë•Œ ì´ì§„ íŠ¸ë¦¬ë¥¼ ì‚¬ìš©í•œë‹¤.

ì´ì§„ íŠ¸ë¦¬ëŠ” ë‘ ê°œì˜ ìì‹ì„ ê°€ì§€ë¯€ë¡œ ë³´í¸ì ìœ¼ë¡œ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ë‚˜ëˆŒ ìˆ˜ ìˆë‹¤.

```markdown
        A                 1
      /   \             /   \
     B     C           2     3
    / \   / \               / \
   D   E F   G             4   5
```

íŠ¸ë¦¬ëŠ” ìœ„ì™€ ê°™ì€ ë°©ì‹ìœ¼ë¡œ ë‚˜íƒ€ë‚¼ ìˆ˜ ìˆë‹¤.

[ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸](https://2unbini.github.io/ğŸ“‚%20all/swift/swift-linked-list/)ì˜ ê°œë…ì„ í™œìš©í•´ ê° ë…¸ë“œê°€ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ìì‹ ë…¸ë“œë¥¼ ë‹´ê³  ìˆì–´ë„ ë˜ì§€ë§Œ, ë…¸ë“œ ìƒì„±ì‹œë§ˆë‹¤ ìƒˆ ë…¸ë“œë¥¼ ë©”ëª¨ë¦¬ì— í• ë‹¹í•´ì•¼ í•˜ë¯€ë¡œ ë°°ì—´ì„ í™œìš©í•˜ì—¬ íŠ¸ë¦¬ë¥¼ ë§Œë“œëŠ” ê²ƒì´ ë” ê²½ì œì ì´ì–´ë³´ì¸ë‹¤. (Cì—ì„œ malloc, freeë¥¼ ì´ìš©í•´ ë™ì í• ë‹¹ í•  ë•Œì˜ ì´ì•¼ê¸°ì§€ë§Œ Swiftì—ì„œ ê°ì²´ ìƒì„±í•˜ëŠ”ë°ë„ ë¹„ìš©ì´ ë“¤í…Œë‹ˆ ë™ì¼í•˜ê²Œ ì ìš©ë  ìˆ˜ ìˆë‹¤ê³  ìƒê°í•œë‹¤. ì•„ë‹ˆë¼ë©´ ëŒ“ê¸€ ë¶€íƒë“œë¦½ë‹ˆë‹¤!)

ê·¸ëŸ¼ ì € êµ¬ì¡°ë¥¼ ë°°ì—´ì—ì„œ ì–´ë–»ê²Œ ë‚˜íƒ€ë‚¼ê¹Œ?

ë°°ì—´ì—ì„œëŠ” `ì¸ë±ìŠ¤`ë¥¼ ì‚¬ìš©í•´ ë¶€ëª¨ì™€ ìì‹ ë…¸ë“œë¥¼ êµ¬ë¶„í•˜ë©´ ëœë‹¤.

![](https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/Binary_tree_in_array.svg/740px-Binary_tree_in_array.svg.png)

ìœ„ ê·¸ë¦¼ì²˜ëŸ¼ ë…¸ë“œì˜ ì¸ë±ìŠ¤ê°€ `i`ì¼ ë•Œ, ê·¸ ë…¸ë“œì˜ ì™¼ìª½ ìì‹ì˜ ì¸ë±ìŠ¤ëŠ” `(i * 2) + 1`, ì˜¤ë¥¸ìª½ ìì‹ì˜ ì¸ë±ìŠ¤ëŠ”`(i * 2) + 2`ê°€ ëœë‹¤.

ì´ê±¸ í™œìš©í•´ ìœ„ì˜ íŠ¸ë¦¬ë¥¼ ë°°ì—´ë¡œ ë‚˜íƒ€ë‚´ë©´

```swift
[A, B, C, D, E, F, G, nil, nil, nil, nil, nil, nil, nil, nil]
[1, 2, 3, nil, nil, 4, 5, nil, nil, nil, nil]
```

ì´ ëœë‹¤.

ì—¬ê¸°ì„œ ë°°ì—´ì˜ ê°œìˆ˜ëŠ” ì „ì²´ ë…¸ë“œì˜ ê°œìˆ˜ ê³±í•˜ê¸° 2ì— 1ì„ ë”í•œ ê°’ê³¼ ê°™ë‹¤. (1 ë”í•˜ëŠ”ê±´ ì¸ë±ìŠ¤ê°€ 0ë¶€í„° ì‹œì‘í•˜ê¸° ë•Œë¬¸)

### nilì€ ë¨¸ì„?

ë¦¬í”„ ë…¸ë“œ, ì¦‰ ë ë…¸ë“œë¥¼ ë‚˜íƒ€ë‚¼ ë•Œ NULL, nil ë“±ì„ ì‚¬ìš©í–ˆë‹¤.

ë°°ì—´ì—ì„œë„ ë§ˆì°¬ê°€ì§€ë¡œ í•´ë‹¹ ë…¸ë“œê°€ ë§ˆì§€ë§‰ ë…¸ë“œë¼ëŠ” ê²ƒì„ ë‚˜íƒ€ë‚´ê¸° ìœ„í•´ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ë…¸ë“œì— ê°ê° nil(Swift)ì„ ì¶”ê°€í•´ì¤¬ë‹¤.

## ì™œ í›„ìœ„í‘œí˜„ì‹ê³¼ ì´ì§„íŠ¸ë¦¬ ê°œë…ì„ í™œìš©í•´ì•¼í•˜ì§€?

í”„ë¡œê·¸ë˜ë°ì„ ìœ„í•´ êµ¬í˜„ëœ ìë£Œêµ¬ì¡°ì¤‘ ìˆ˜ì‹ì„ í‘œí˜„í•˜ëŠ” ì´ì§„ íŠ¸ë¦¬ê°€ ìˆëŠ”ë° ì´ë¥¼ [Binary Expression Tree](https://en.wikipedia.org/wiki/Binary_expression_tree)ë¼ê³  í•œë‹¤.

ì´ëŠ” ìœ„ì—ì„œ ì„¤ëª…í•œ ê²ƒì²˜ëŸ¼ ì´ì§„ íŠ¸ë¦¬ë¡œ êµ¬ì„±ë¼ìˆê³ , ê° í‘œí˜„ì‹ì„ ì—°ì‚°í•˜ëŠ” ë°©ë²•ìœ¼ë¡œ ì¼ë°˜ì ìœ¼ë¡œ í›„ìœ„ ìˆœíšŒë¥¼ ì±„íƒí•œë‹¤.

ì˜ ì•Œë ¤ì ¸ìˆëŠ” ìë£Œêµ¬ì¡°ë¥¼ í™œìš©í•´ ì¡°ê¸ˆ ë” ì•Œê³ ë¦¬ì¦˜ì„ ì‰½ê²Œ ë§Œë“¤ê¸° ìœ„í•´ ì¤‘ìœ„í‘œí˜„ì‹ì„ í›„ìœ„í‘œí˜„ì‹ìœ¼ë¡œ, í›„ìœ„í‘œí˜„ì‹ì„ ì´ì§„ íŠ¸ë¦¬ë¡œ, ì´ì§„ íŠ¸ë¦¬ë¥¼ í›„ìœ„ ìˆœíšŒí•˜ë©´ì„œ ê°’ì„ ë‚´ë„ë¡ í–ˆë‹¤.

## êµ¬í˜„í•˜ê¸°

### ì¤‘ìœ„í‘œí˜„ì‹ -> í›„ìœ„í‘œí˜„ì‹

`String`ìœ¼ë¡œ ë“¤ì–´ì˜¨ ì¤‘ìœ„í‘œí˜„ì‹ì„ `Array<String>` í˜•ì‹ì˜ í›„ìœ„í‘œí˜„ì‹(ë°°ì—´)ìœ¼ë¡œ ê°’ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“¤ì—ˆë‹¤.

ì—¬ê¸°ì„œ ì¸ìë¡œ ë“¤ì–´ê°€ëŠ” `infixExpression`ì€ `1+(2+3)*7`ê³¼ ê°™ì´ ê³µë°± ì—†ì´ ê´„í˜¸ í¬í•¨ëœ ë¬¸ìì—´ì˜ ìƒíƒœë‹¤. ê³µë°±ì´ ìˆê±°ë‚˜ ê´„í˜¸ê°€ ì—†ëŠ” ì¡°ê±´ì´ë¼ë©´ infixExpressionì˜ ê° ì›ì†Œë¥¼ ìˆœíšŒí•˜ê¸° ì „ `split`ì„ ì‚¬ìš©í•˜ê³ , ì—°ì‚°ì ìš°ì„ ìˆœìœ„ì— ë”°ë¼ ìŠ¤íƒ push/popí•˜ëŠ” ê³¼ì •ì—ì„œ ê´„í˜¸ë¥¼ ì œê±°í•˜ë©´ ëœë‹¤.

```swift
/// ì¤‘ìœ„í‘œí˜„ì‹ì„ í›„ìœ„í‘œí˜„ì‹ì˜ ë°°ì—´ë¡œ ë§Œë“¤ê¸°
func infixToPostfix(_ infixExpression: String) -> [String] {

     // ì—°ì‚°ì ìš°ì„ ìˆœìœ„ë¥¼ ìœ„í•œ ë”•ì…”ë„ˆë¦¬
    let operatorPriority: [Character: Int] = ["(": 0, ")": 0, "+": 1, "-": 1, "*": 2, "/": 2]

    // ë°˜í™˜í•  í›„ìœ„í‘œí˜„ì‹ ë°°ì—´
    var postfixExpression: [String] = []

    // ìš°ì„ ìˆœìœ„ëŒ€ë¡œ push/popë  ì—°ì‚°ì ìŠ¤íƒ
    var operatorStack: [Character] = []

    
    // ì¤‘ìœ„í‘œí˜„ì‹ì—ì„œ ê° ë¬¸ì(í† í°) íŒë³„
    for token in infixExpression {
        
        // ìš°ì„ ìˆœìœ„ê°€ ìˆìœ¼ë©´ ì—°ì‚°ì
        // 1. ê´„í˜¸ ì²´í¬
        // 2. ìš°ì„ ìˆœìœ„ ì²´í¬
        if let priority = operatorPriority[token] {
            
            // ê´„í˜¸ì¼ë•Œ
            if priority == 0 {
                
                // ì™¼ìª½ ê´„í˜¸ë©´ ìŠ¤íƒì— ì¶”ê°€
                if token == "(" {
                    operatorStack.append(token)
                }
                // ì˜¤ë¥¸ìª½ ê´„í˜¸ë©´ ìŠ¤íƒì—ì„œ "(" ë‚˜ì˜¬ ë•Œê¹Œì§€ removeLast()í•˜ê³  í›„ìœ„í‘œí˜„ì‹ ë°°ì—´ì— ì¶”ê°€
                else {
                    while !operatorStack.isEmpty {
                        let lastOperator = operatorStack.removeLast()
                        
                        if lastOperator == "(" {
                            break
                        } else {
                            postfixExpression.append(String(lastOperator))
                        }
                    }
                }
            }
            // ê´„í˜¸ ì•„ë‹Œ ì—°ì‚°ìì¼ë•Œ
            else {
                
                // ì—°ì‚°ì ìŠ¤íƒì˜ ë§ˆì§€ë§‰ ì—°ì‚°ìë³´ë‹¤ í˜„ì¬ ì—°ì‚°ìì˜ ìš°ì„ ìˆœìœ„ê°€ ë‚®ê±°ë‚˜ ê°™ìœ¼ë©´ ë¨¼ì € í›„ìœ„í‘œí˜„ì‹ ë°°ì—´ì— ì¶”ê°€
                while !operatorStack.isEmpty && priority <= operatorPriority[operatorStack.last!]! {
                    let lastOperator = String(operatorStack.removeLast())
                    
                    postfixExpression.append(lastOperator)
                }
                
                // í˜„ì¬ ì—°ì‚°ìì˜ ìš°ì„ ìˆœìœ„ê°€ ë†’ìœ¼ë©´ ì—°ì‚°ì ìŠ¤íƒì— í˜„ì¬ ì—°ì‚°ì ì¶”ê°€
                operatorStack.append(token)
            }
        }
        // ìš°ì„ ìˆœìœ„ê°€ ì—†ìœ¼ë©´ í”¼ì—°ì‚°ì
        // Stringìœ¼ë¡œ ë³€í™˜ í›„ ë°°ì—´ì— ì¶”ê°€
        else {
            postfixExpression.append(String(token))
        }
    }
    
    // ì—°ì‚°ì ìŠ¤íƒì— ë‚¨ì•„ ìˆëŠ” ëª¨ë“  ì—°ì‚°ìë“¤ í›„ìœ„í‘œí˜„ì‹ ë°°ì—´ì— ì¶”ê°€
    while !operatorStack.isEmpty {
        let lastOperator = String(operatorStack.removeLast())
        
        postfixExpression.append(lastOperator)
    }
    
    return postfixExpression
}
```

### í›„ìœ„í‘œí˜„ì‹ -> ì´ì§„ íŠ¸ë¦¬(ë°°ì—´)

`Array<String>` í˜•ì‹ìœ¼ë¡œ ë‚˜ì˜¨ í›„ìœ„í‘œí˜„ì‹ ë°°ì—´ì„ ë°°ì—´ í˜•íƒœì˜ ì´ì§„ íŠ¸ë¦¬ë¡œ ë³€í™˜í•œë‹¤.

í›„ìœ„í‘œí˜„ì‹ì´ë¯€ë¡œ ê°€ì¥ ìš°ì„ ìˆœìœ„ê°€ ë†’ì€ ì—°ì‚°ìê°€ ë§¨ ë’¤ì— ìˆê³ , í•´ë‹¹ ì—°ì‚°ìì˜ í”¼ì—°ì‚°ìëŠ” ê°ê° ë§¨ ë’¤ì—ì„œ -1, -2ì— ìœ„ì¹˜í•œë‹¤. ì´ë¥¼ ì¬ê·€ì ìœ¼ë¡œ íƒ€ê³  ë‚´ë ¤ê°€ë©´ì„œ ë°°ì—´ì— ì¶”ê°€í•´ì£¼ë©´ ëœë‹¤.

```swift
/// í›„ìœ„ì—°ì‚°ì ë°°ì—´ì„ ìˆ˜ì‹íŠ¸ë¦¬ë¡œ ë§Œë“¤ê¸°
/// treeëŠ” postfixExpression ë°°ì—´ì˜ ê°œìˆ˜ * 2 + 1, ê° ì›ì†ŒëŠ” nilë¡œ ì´ˆê¸°í™”í•œ í›„ ì‚¬ìš©í•´ì•¼ í•¨
func buildExpressionTree(
    with postfixExpression: inout [String],
    _ tree: inout [String?],
    _ index: Int
) {
    guard let token = postfixExpression.popLast()
    else { return }
    
    switch token {
    case "+", "-", "*", "/":
        // ë£¨íŠ¸ê°€ ë¨
        // ì˜¤ë¥¸ìª½ íŠ¸ë¦¬ ë§Œë“¤ëŸ¬ ë‚´ë ¤ê°
        // ì™¼ìª½ íŠ¸ë¦¬ ë§Œë“¤ëŸ¬ ë‚´ë ¤ê°
        tree[index] = token
        buildExpressionTree(with: &postfixExpression, &tree, index * 2 + 2)
        buildExpressionTree(with: &postfixExpression, &tree, index * 2 + 1)
    default:
        // ë¦¬í”„ê°€ ë¨
        tree[index] = token
    }
}
```

ì—¬ê¸°ì„œ `tree`ëŠ” í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•˜ê¸° ì „ ì •ì˜ë˜ì–´ì•¼í•œë‹¤.

```swift
// ì˜ˆì‹œ
var postfixExpression = infixToPostfix("(1+2)-(7*8)")
var tree: [String?] = Array(repeating: nil, count: postfixExpression.count + 1)

buildExpressionTree(&postfixExpression, &tree, 0)
```

### ì´ì§„ íŠ¸ë¦¬ í›„ìœ„ ìˆœíšŒí•˜ë©° ì—°ì‚°

ë§Œë“¤ì–´ì§„ ì´ì§„ íŠ¸ë¦¬(ìˆ˜ì‹ íŠ¸ë¦¬)ë¥¼ í›„ìœ„ ìˆœíšŒí•˜ë©° ì—°ì‚°í•´ë‚˜ê°€ë©´ ëì´ë‹¤.

> í›„ìœ„ ìˆœíšŒ: ì™¼ìª½ìì‹ë…¸ë“œ - ì˜¤ë¥¸ìª½ìì‹ë…¸ë“œ - ë¶€ëª¨ë…¸ë“œ ìˆœì„œë¡œ ìˆœíšŒí•˜ëŠ” ê²ƒ.

```swift
/// ìˆ˜ì‹íŠ¸ë¦¬ë¥¼ íƒìƒ‰í•˜ë©´ì„œ ê²°ê³¼ê°’ ë‚´ê¸°
func valueOfExpressionTree(with tree: [String?], _ index: Int) -> Int {
    guard index < tree.count,
          let node = tree[index]
    else { return 0 }
    
    let leftIndex = index * 2 + 1
    let rightIndex = index * 2 + 2
    
    // ì™¼ìª½, ì˜¤ë¥¸ìª½ ìˆ«ì í˜¹ì€ ì—°ì‚°ê°’ ë‚˜ì˜¬ë•Œê¹Œì§€ ì¬ê·€
    let leftNum = valueOfExpressionTree(with: tree, leftIndex)
    let rightNum = valueOfExpressionTree(with: tree, rightIndex)
    
    switch node {
    case "+", "-", "*", "/":
        if node == "+" { return leftNum + rightNum }
        else if node == "-" { return leftNum - rightNum }
        else if node == "*" { return leftNum * rightNum }
        else { return leftNum / rightNum }
    default:
        return Int(node)!
    }
}
```

### ê²°ê³¼

ìœ„ ì½”ë“œë¥¼ ëŒë ¤ë³´ë©´ ë‹¤ìŒê³¼ ê°™ì´ ë‚˜ì˜¨ë‹¤.

![](/assets/images/algorithm/value.png)

## ì°¸ê³ 

[ì´ê²ƒì´ ìë£Œêµ¬ì¡°+ì•Œê³ ë¦¬ì¦˜ì´ë‹¤ with Cì–¸ì–´ - ë°•ìƒí˜„, í•œë¹›ë¯¸ë””ì–´](https://m.hanbit.co.kr/media/books/book_view.html?p_code=B9034896671)